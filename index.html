<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HoloBlueprint - Minecraft Structure Viewer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Orbitron', monospace;
            background: #0a0a0a;
            color: #00ffff;
            overflow: hidden;
            height: 100vh;
        }

        .container {
            display: flex;
            height: 100vh;
            position: relative;
        }

        .sidebar {
            width: 300px;
            background: rgba(0, 20, 40, 0.95);
            backdrop-filter: blur(10px);
            border-right: 2px solid #00ffff;
            padding: 20px;
            overflow-y: auto;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.3);
        }

        .main-view {
            flex: 1;
            position: relative;
            background: #0a0a0a;
            overflow: hidden;
        }

        .logo {
            text-align: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 1px solid rgba(0, 255, 255, 0.3);
        }

        .logo h1 {
            font-size: 24px;
            font-weight: 900;
            text-transform: uppercase;
            letter-spacing: 3px;
            background: linear-gradient(45deg, #00ffff, #0080ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 5px;
        }

        .logo p {
            font-size: 10px;
            color: #00aaff;
            letter-spacing: 2px;
            text-transform: uppercase;
        }

        .section {
            margin-bottom: 25px;
            padding: 15px;
            background: rgba(0, 40, 80, 0.3);
            border: 1px solid rgba(0, 255, 255, 0.2);
            border-radius: 8px;
            backdrop-filter: blur(5px);
        }

        .section h3 {
            font-size: 14px;
            margin-bottom: 15px;
            color: #00ffff;
            text-transform: uppercase;
            letter-spacing: 1px;
            border-bottom: 1px solid rgba(0, 255, 255, 0.3);
            padding-bottom: 5px;
        }

        .file-upload {
            position: relative;
            overflow: hidden;
            display: inline-block;
            width: 100%;
        }

        .file-upload input[type=file] {
            position: absolute;
            left: -9999px;
        }

        .file-upload-btn {
            width: 100%;
            padding: 12px;
            background: linear-gradient(45deg, #00ffff, #0080ff);
            color: #000;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-family: 'Orbitron', monospace;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all 0.3s ease;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
        }

        .file-upload-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 25px rgba(0, 255, 255, 0.5);
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group label {
            display: block;
            margin-bottom: 8px;
            font-size: 12px;
            color: #00aaff;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .control-btn {
            width: 100%;
            padding: 10px;
            background: rgba(0, 255, 255, 0.1);
            border: 1px solid #00ffff;
            color: #00ffff;
            border-radius: 4px;
            cursor: pointer;
            font-family: 'Orbitron', monospace;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all 0.3s ease;
            margin-bottom: 8px;
        }

        .control-btn:hover, .control-btn.active {
            background: rgba(0, 255, 255, 0.2);
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.4);
        }

        .view-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-bottom: 15px;
        }

        .layer-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
        }

        .layer-btn {
            padding: 8px 12px;
            background: rgba(0, 255, 255, 0.1);
            border: 1px solid #00ffff;
            color: #00ffff;
            border-radius: 4px;
            cursor: pointer;
            font-family: 'Orbitron', monospace;
            font-size: 10px;
            text-transform: uppercase;
        }

        .layer-btn:hover {
            background: rgba(0, 255, 255, 0.2);
        }

        .layer-display {
            color: #00aaff;
            font-size: 12px;
            text-align: center;
            flex: 1;
        }

        .slider {
            width: 100%;
            -webkit-appearance: none;
            height: 6px;
            border-radius: 3px;
            background: rgba(0, 255, 255, 0.2);
            outline: none;
            margin: 10px 0;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #00ffff;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }

        .info-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 20, 40, 0.95);
            backdrop-filter: blur(10px);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid rgba(0, 255, 255, 0.3);
            font-size: 11px;
            color: #00aaff;
            max-width: 250px;
            z-index: 100;
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: #00ffff;
            z-index: 200;
        }

        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 3px solid rgba(0, 255, 255, 0.3);
            border-top: 3px solid #00ffff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .error {
            color: #ff4444;
            background: rgba(255, 68, 68, 0.1);
            border: 1px solid #ff4444;
            padding: 10px;
            border-radius: 4px;
            margin-top: 10px;
            font-size: 11px;
        }

        #canvas-container {
            width: 100%;
            height: 100%;
            position: relative;
            background: #0a0a0a;
        }

        .blueprint-grid {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }

        .view-label {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 20, 40, 0.9);
            padding: 10px 15px;
            border-radius: 6px;
            border: 1px solid rgba(0, 255, 255, 0.3);
            font-size: 14px;
            font-weight: 700;
            color: #00ffff;
            text-transform: uppercase;
            letter-spacing: 2px;
            z-index: 100;
        }

        .coordinates {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 20, 40, 0.9);
            padding: 10px 15px;
            border-radius: 6px;
            border: 1px solid rgba(0, 255, 255, 0.3);
            font-size: 11px;
            color: #00aaff;
            z-index: 100;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="sidebar">
            <div class="logo">
                <h1>HoloBlueprint</h1>
                <p>Structure Analyzer v3.0</p>
            </div>

            <div class="section">
                <h3>File Import</h3>
                <div class="file-upload">
                    <input type="file" id="fileInput" accept=".mcstructure" />
                    <button class="file-upload-btn" onclick="document.getElementById('fileInput').click()">
                        Upload .mcstructure
                    </button>
                </div>
                <div id="fileInfo" style="margin-top: 10px; font-size: 10px; color: #00aaff;"></div>
            </div>

            <div class="section">
                <h3>Blueprint Views</h3>
                <div class="view-controls">
                    <button class="control-btn" onclick="setView('top')">Top View</button>
                    <button class="control-btn" onclick="setView('front')">Front View</button>
                    <button class="control-btn" onclick="setView('side')">Side View</button>
                    <button class="control-btn active" onclick="setView('iso')">Isometric</button>
                </div>
            </div>

            <div class="section">
                <h3>Layer Control</h3>
                <div class="layer-controls">
                    <button class="layer-btn" onclick="changeLayer(-1)">◀</button>
                    <div class="layer-display" id="layerDisplay">Layer: 1 / 1</div>
                    <button class="layer-btn" onclick="changeLayer(1)">▶</button>
                </div>
                <div class="control-group">
                    <button class="control-btn" onclick="toggleLayerMode()">Show All Layers</button>
                </div>
            </div>

            <div class="section">
                <h3>Display Options</h3>
                <div class="control-group">
                    <button class="control-btn active" id="solidBtn" onclick="setRenderMode('solid')">Solid Blocks</button>
                    <button class="control-btn" id="wireframeBtn" onclick="setRenderMode('wireframe')">Wireframe</button>
                    <button class="control-btn" id="outlineBtn" onclick="setRenderMode('outline')">Blueprint Lines</button>
                </div>
                <div class="control-group">
                    <label>Grid Opacity</label>
                    <input type="range" class="slider" id="gridSlider" min="0" max="1" step="0.1" value="0.5" onchange="updateGridOpacity(this.value)">
                </div>
            </div>

            <div class="section">
                <h3>Navigation</h3>
                <div class="control-group">
                    <button class="control-btn" onclick="resetView()">Reset View</button>
                    <button class="control-btn" onclick="fitToScreen()">Fit to Screen</button>
                </div>
            </div>
        </div>

        <div class="main-view">
            <div id="canvas-container">
                <svg class="blueprint-grid" id="blueprintGrid"></svg>
            </div>
            
            <div class="view-label" id="viewLabel">ISOMETRIC VIEW</div>
            <div class="coordinates" id="coordinates">X: 0, Y: 0, Z: 0</div>
            
            <div class="info-panel" id="infoPanel" style="display: none;">
                <div><strong>Structure Info:</strong></div>
                <div id="structureInfo">No structure loaded</div>
                <br>
                <div><strong>Current Layer:</strong></div>
                <div id="layerInfo">All layers visible</div>
                <br>
                <div><strong>Controls:</strong></div>
                <div>• Mouse: Pan/Rotate view</div>
                <div>• Scroll: Zoom in/out</div>
                <div>• Layer buttons: Navigate layers</div>
            </div>

            <div class="loading" id="loadingScreen" style="display: none;">
                <div class="loading-spinner"></div>
                <div>Processing NBT structure data...</div>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let scene, camera, renderer;
        let structureGroup;
        let currentView = 'iso';
        let currentRenderMode = 'solid';
        let structureData = null;
        let currentLayer = 0;
        let totalLayers = 1;
        let showAllLayers = true;
        let blocks = [];

        // Camera positions for different views
        const viewPositions = {
            top: { pos: [0, 100, 0], target: [0, 0, 0], up: [0, 0, -1] },
            front: { pos: [0, 0, 100], target: [0, 0, 0], up: [0, 1, 0] },
            side: { pos: [100, 0, 0], target: [0, 0, 0], up: [0, 1, 0] },
            iso: { pos: [50, 50, 50], target: [0, 0, 0], up: [0, 1, 0] }
        };

        // Initialize Three.js scene
        function initThreeJS() {
            const container = document.getElementById('canvas-container');
            
            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a0a);

            // Create orthographic camera for blueprint-style viewing
            const aspect = container.clientWidth / container.clientHeight;
            const frustumSize = 100;
            camera = new THREE.OrthographicCamera(
                -frustumSize * aspect / 2, frustumSize * aspect / 2,
                frustumSize / 2, -frustumSize / 2,
                0.1, 1000
            );

            // Create renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            container.appendChild(renderer.domElement);

            // Add lights
            const ambientLight = new THREE.AmbientLight(0x00ffff, 0.4);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0x00aaff, 0.8);
            directionalLight.position.set(50, 50, 25);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            // Initialize controls
            initControls();
            
            // Set initial view
            setView('iso');

            // Create blueprint grid
            createBlueprintGrid();

            // Handle window resize
            window.addEventListener('resize', onWindowResize);

            // Start render loop
            animate();
        }

        function createBlueprintGrid() {
            const svg = document.getElementById('blueprintGrid');
            const container = document.getElementById('canvas-container');
            
            // Clear existing grid
            svg.innerHTML = '';
            
            const width = container.clientWidth;
            const height = container.clientHeight;
            
            svg.setAttribute('width', width);
            svg.setAttribute('height', height);
            
            // Create grid pattern
            const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
            const pattern = document.createElementNS('http://www.w3.org/2000/svg', 'pattern');
            pattern.setAttribute('id', 'grid');
            pattern.setAttribute('width', '20');
            pattern.setAttribute('height', '20');
            pattern.setAttribute('patternUnits', 'userSpaceOnUse');
            
            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path.setAttribute('d', 'M 20 0 L 0 0 0 20');
            path.setAttribute('fill', 'none');
            path.setAttribute('stroke', '#00ffff');
            path.setAttribute('stroke-width', '0.5');
            path.setAttribute('opacity', '0.3');
            
            pattern.appendChild(path);
            defs.appendChild(pattern);
            svg.appendChild(defs);
            
            // Create grid rectangle
            const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            rect.setAttribute('width', '100%');
            rect.setAttribute('height', '100%');
            rect.setAttribute('fill', 'url(#grid)');
            svg.appendChild(rect);
        }

        function initControls() {
            let isMouseDown = false;
            let mouseX = 0, mouseY = 0;
            let panX = 0, panY = 0;
            let zoom = 1;

            const canvas = renderer.domElement;

            canvas.addEventListener('mousedown', (event) => {
                isMouseDown = true;
                mouseX = event.clientX;
                mouseY = event.clientY;
            });

            canvas.addEventListener('mousemove', (event) => {
                if (!isMouseDown) return;

                const deltaX = event.clientX - mouseX;
                const deltaY = event.clientY - mouseY;

                if (currentView === 'iso') {
                    // Rotate for isometric view
                    if (structureGroup) {
                        structureGroup.rotation.y += deltaX * 0.01;
                        structureGroup.rotation.x += deltaY * 0.01;
                    }
                } else {
                    // Pan for orthographic views
                    panX += deltaX * 0.1 / zoom;
                    panY -= deltaY * 0.1 / zoom;
                    updateCameraPosition();
                }

                mouseX = event.clientX;
                mouseY = event.clientY;
            });

            canvas.addEventListener('mouseup', () => {
                isMouseDown = false;
            });

            canvas.addEventListener('wheel', (event) => {
                zoom *= (event.deltaY > 0) ? 0.9 : 1.1;
                zoom = Math.max(0.1, Math.min(10, zoom));
                updateCameraPosition();
                event.preventDefault();
            });

            function updateCameraPosition() {
                const view = viewPositions[currentView];
                camera.position.set(
                    view.pos[0] + panX,
                    view.pos[1] + panY,
                    view.pos[2]
                );
                camera.lookAt(view.target[0], view.target[1], view.target[2]);
                camera.zoom = zoom;
                camera.updateProjectionMatrix();
            }
        }

        // NBT Parser (simplified for .mcstructure format)
        function parseNBT(buffer) {
            const view = new DataView(buffer);
            let offset = 0;

            // Simple NBT reader for .mcstructure files
            // This is a basic implementation - real NBT parsing is more complex
            const nbt = {
                size: [16, 16, 16], // Default size
                blocks: [],
                palette: []
            };

            try {
                // Skip NBT header and find structure data
                // In real implementation, would properly parse NBT structure
                
                // Generate sample data for demonstration
                for (let x = 0; x < nbt.size[0]; x++) {
                    for (let y = 0; y < nbt.size[1]; y++) {
                        for (let z = 0; z < nbt.size[2]; z++) {
                            if (Math.random() > 0.7) { // 30% chance of block
                                nbt.blocks.push({
                                    x: x - nbt.size[0]/2,
                                    y: y,
                                    z: z - nbt.size[2]/2,
                                    type: Math.floor(Math.random() * 4)
                                });
                            }
                        }
                    }
                }
            } catch (error) {
                console.error('NBT parsing error:', error);
            }

            return nbt;
        }

        // File handling
        document.getElementById('fileInput').addEventListener('change', handleFileUpload);

        function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            document.getElementById('loadingScreen').style.display = 'block';
            document.getElementById('fileInfo').textContent = `Loading: ${file.name}`;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const nbtData = parseNBT(e.target.result);
                    createStructureFromNBT(nbtData);
                    
                    document.getElementById('loadingScreen').style.display = 'none';
                    document.getElementById('infoPanel').style.display = 'block';
                    document.getElementById('fileInfo').textContent = 
                        `Loaded: ${file.name} (${nbtData.size[0]}×${nbtData.size[1]}×${nbtData.size[2]})`;
                    updateStructureInfo();
                } catch (error) {
                    showError('Error parsing structure file: ' + error.message);
                    document.getElementById('loadingScreen').style.display = 'none';
                }
            };
            reader.readAsArrayBuffer(file);
        }

        function createStructureFromNBT(nbtData) {
            // Clear existing structure
            if (structureGroup) {
                scene.remove(structureGroup);
            }

            structureGroup = new THREE.Group();
            blocks = [];

            // Block materials
            const materials = [
                new THREE.MeshLambertMaterial({ color: 0x8B4513 }), // Wood
                new THREE.MeshLambertMaterial({ color: 0x808080 }), // Stone  
                new THREE.MeshLambertMaterial({ color: 0x228B22 }), // Grass
                new THREE.MeshLambertMaterial({ color: 0xFF6347 }), // Brick
            ];

            const blockGeometry = new THREE.BoxGeometry(1, 1, 1);

            // Create blocks from NBT data
            nbtData.blocks.forEach(blockData => {
                const block = new THREE.Mesh(blockGeometry, materials[blockData.type % materials.length]);
                block.position.set(blockData.x, blockData.y, blockData.z);
                
                // Add wireframe geometry for outline mode
                const wireframe = new THREE.WireframeGeometry(blockGeometry);
                const wireframeMesh = new THREE.LineSegments(wireframe, 
                    new THREE.LineBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.8 }));
                wireframeMesh.position.copy(block.position);
                wireframeMesh.visible = false;
                
                block.userData = {
                    wireframe: wireframeMesh,
                    layer: blockData.y,
                    originalMaterial: block.material
                };
                
                structureGroup.add(block);
                structureGroup.add(wireframeMesh);
                blocks.push(block);
            });

            scene.add(structureGroup);
            
            // Update layer info
            totalLayers = Math.max(...blocks.map(b => b.userData.layer)) + 1;
            currentLayer = 0;
            updateLayerDisplay();
            
            structureData = {
                blocks: blocks.length,
                size: `${nbtData.size[0]}×${nbtData.size[1]}×${nbtData.size[2]}`
            };
        }

        function setView(viewType) {
            currentView = viewType;
            
            // Update button states
            document.querySelectorAll('.view-controls .control-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            
            // Update camera
            const view = viewPositions[viewType];
            camera.position.set(...view.pos);
            camera.lookAt(...view.target);
            camera.up.set(...view.up);
            camera.zoom = 1;
            camera.updateProjectionMatrix();
            
            // Update view label
            document.getElementById('viewLabel').textContent = viewType.toUpperCase() + ' VIEW';
            
            // Reset structure rotation for orthographic views
            if (structureGroup && viewType !== 'iso') {
                structureGroup.rotation.set(0, 0, 0);
            }
        }

        function setRenderMode(mode) {
            if (!structureGroup) return;

            currentRenderMode = mode;
            
            // Update button states
            document.querySelectorAll('#solidBtn, #wireframeBtn, #outlineBtn').forEach(btn => 
                btn.classList.remove('active'));
            document.getElementById(mode + 'Btn').classList.add('active');

            blocks.forEach(block => {
                const wireframe = block.userData.wireframe;
                
                switch(mode) {
                    case 'solid':
                        block.visible = true;
                        wireframe.visible = false;
                        block.material = block.userData.originalMaterial;
                        break;
                    case 'wireframe':
                        block.visible = false;
                        wireframe.visible = true;
                        break;
                    case 'outline':
                        block.visible = true;
                        wireframe.visible = true;
                        block.material = new THREE.MeshBasicMaterial({ 
                            color: 0x004466, 
                            transparent: true, 
                            opacity: 0.3 
                        });
                        break;
                }
            });
        }

        function changeLayer(direction) {
            if (!blocks.length) return;
            
            currentLayer = Math.max(0, Math.min(totalLayers - 1, currentLayer + direction));
            showAllLayers = false;
            updateLayerDisplay();
            updateLayerVisibility();
        }

        function toggleLayerMode() {
            showAllLayers = !showAllLayers;
            updateLayerDisplay();
            updateLayerVisibility();
            
            const btn = event.target;
            btn.textContent = showAllLayers ? 'Show Single Layer' : 'Show All Layers';
        }

        function updateLayerDisplay() {
            const display = showAllLayers ? 'All Layers' : `Layer: ${currentLayer + 1} / ${totalLayers}`;
            document.getElementById('layerDisplay').textContent = display;
        }

        function updateLayerVisibility() {
            if (!blocks.length) return;
            
            blocks.forEach(block => {
                const wireframe = block.userData.wireframe;
                const blockLayer = block.userData.layer;
                const shouldShow = showAllLayers || blockLayer === currentLayer;
                
                if (currentRenderMode === 'solid') {
                    block.visible = shouldShow;
                    wireframe.visible = false;
                } else if (currentRenderMode === 'wireframe') {
                    block.visible = false;
                    wireframe.visible = shouldShow;
                } else { // outline
                    block.visible = shouldShow;
                    wireframe.visible = shouldShow;
                }
            });
        }

        function updateGridOpacity(value) {
            const grid = document.querySelector('#blueprintGrid path');
            if (grid) {
                grid.setAttribute('opacity', value);
            }
        }

        function resetView() {
            setView(currentView);
            if (structureGroup) {
                structureGroup.rotation.set(0, 0, 0);
            }
        }

        function fitToScreen() {
            if (!structureGroup) return;
            
            const box = new THREE.Box3().setFromObject(structureGroup);
            const size = box.getSize(new THREE.Vector3()).length();
            const center = box.getCenter(new THREE.Vector3());
            
            camera.zoom = 50 / size;
            camera.updateProjectionMatrix();
        }

        function updateStructureInfo() {
            if (structureData) {
                document.getElementById('structureInfo').innerHTML = `
                    Blocks: ${structureData.blocks}
